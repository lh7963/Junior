----------------------------------------------------------------------

Module:         G52AFP Advanced Functional Programming
School:         Computer Science, University of Nottingham
Lecturer:       Prof Graham Hutton
Level:          2
Semester:       Spring
Year:           17-18

----------------------------------------------------------------------

QUESTION 1:

a) class Functor f where
      fmap :: (a -> b) -> f a -> f b

   This definition generalises the higher-order function map ::
   (a -> b) -> [a] -> [b] from lists to any parameterised type.

b) instance Functor Result where
      -- fmap :: (a -> b) -> Result a -> Result b
      fmap g Fail        = Fail
      fmap g (Succeed x) = Succeed (g x)

c) class Functor f => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b

   That is, an applicative functor is a functorial type f that
   supports pure and <*> functions of the specified types.  The
   function pure converts a value of type a into a structure of
   type f a, while <*> is a generalised form of function application
   for which the argument function, the argument value, and the
   result value are all contained in f structures.

d) instance Applicative Result where
      -- pure :: a -> Result a
      pure x = Succeed x

      -- (<*>) :: Result (a -> b) -> Result a -> Result b
      Fail        <*> rx = Fail
      (Succeed g) <*> rx = fmap g rx

   The <*> operator can also be defined by

      Fail        <*> rx          = Fail
      (Succeed g) <*> Fail        = Fail
      (Succeed g) <*> (Succeed x) = Succeed (g x)

e) A typical use of pure and <*> has the form

      pure g <*> x1 <*> x2 <*> ... <*> xn

   This is called applicative style, because of the similarity to
   the standard notation for function application

      g x1 x2 ... xn

   Using this notation, the fmap functions can be defined by:

      fmap1 g x     = pure g <*> x

      fmap2 g x y   = pure g <*> x <*> y

      fmap3 g x y z = pure g <*> x <*> y <*> z

f) The expression is not type correct.  In particular, the function
   safediv has type Int -> Int -> Maybe Int, whereas in the given
   expression a function of type Int -> Int -> Int is required.

----------------------------------------------------------------------

QUESTION 2:

a) type ST a = State -> (a,State)

   That is, a state transformer of type a is a function that
   takes an initial state, and returns a result value of type
   a together with a final state, in which the final state
   reflects any side effects performed by the function.

b) return   :: a -> ST a
   return x =  \s -> (x,s)

   That is, return converts a value into a state transformer that
   simply returns that value without modifying the state.

	|		  ^
      x |    +-------+	  | x
	`----|-------|----'
             |	     |  
      -------|-------|------>
	 s   +-------+	 s

   (>>=)    :: ST a -> (a -> ST b) -> ST b
   st >>= f =  \s -> let (x,s') = st s in f x s'

   That is, >>= provides a means of sequencing state transformers:
   st >>= f applies the state transformer st to an initial state
   s, then applies the function f to the resulting value x to
   give a second state transformer (f x), which is then applied
   to the modified state s' to give the final result.

                                           ^
             +-------+	 x    +-------+	   |
	s    |	     | -----> |	      | ---'
      -----> |	st   |	      |   f   |
             |	     | -----> |	      | ----->
             +-------+	 s'   +-------+

c) relabel (Leaf x)   n = (Leaf n, n+1)
   relabel (Node l r) n = (Node l' r', n'')
			   where
                              (l',n')  = relabel l n
                              (r',n'') = relabel r n'

d) type State	      =  Int

   fresh	      :: ST Int
   fresh	      =  \n -> (n, n+1)

   relabel 	      :: Tree a -> ST (Tree Int)
   relabel (Leaf x)   =  do n <- fresh
                            return (Leaf n)
   relabel (Node l r) =  do l' <- relabel l
                            r' <- relabel r
                            return (Node l' r')

e) The programmer does not have to worry about the tedious and
   error-prone task of dealing with the plumbing of fresh labels,
   as this is handled automatically by the state monad.

----------------------------------------------------------------------

QUESTION 3:

a) Induction can be captured by the following inference rule:

      P []     forall x,xs. P (xs) => P (x:xs)
      ----------------------------------------
                 forall xs. P (xs)
   
   That is, if we want to prove that some property P holds for
   all lists, it is sufficient to show that P holds for [] (the
   base case), and that P is preserved by : (the inductive case).
   More precisely, in the inductive case one is required to show
   that if P holds for any list xs (the induction hypothesis),
   then it also holds for any list x:xs with one extra element.

b) Base case:

    length (reverse [])
  =   applying reverse
    length []

   Inductive case:
  
     length (reverse (x:xs))
   =    applying reverse
     length (reverse xs ++ [x])
   =    lemma
     length (reverse xs) + length [x]
   =    induction hypothesis
     length xs + length [x]
   =    applying length
     length xs + 1
   =    commutativity
     1 + length xs
   =    unapplying length
     length (x:xs)

c) fastrev xs = rev xs []

   rev []     ys = ys
   rev (x:xs) ys = rev xs (x:ys)

d) Base case:

     reverse [] ++ ys
   =   applying reverse
     [] ++ ys
   =   applying ++
     ys 
   =   unapplying rev
     rev [] ys

   Inductive case:

     reverse (x:xs) ++ ys
   =   applying reverse
     (rev xs ++ [x]) ++ ys
   =   associativity of ++
     reverse xs ++ ([x] ++ ys)
   =   applying ++
     reverse xs ++ (x:ys)
   =   induction hypothesis
     rev xs (x:ys)
   =   unapplying rev
     rev (x:xs) ys

e) The definition for reverse is inefficient due to the use of
   the ++ operator, which takes linear time in the length of its
   first argument, and hence results in reverse taking quadratic
   time in the length of the argument list.  The definition of
   fastrev is more efficient because it uses an extra argument
   to accumulate the result by means of the : operator that
   takes constant time, and hence fastrev takes linear time.

----------------------------------------------------------------------

QUESTION 4:

a) leaves (Leaf x)   = [x]
   leaves (Node l r) = leaves l ++ leaves r

   size t = length (leaves t)

   or

   size (Leaf x)   = 1
   size (Node l r) = size l + size r

b) balanced (Leaf x)   = True
   balanced (Node l r) = size l == size r
                         && balanced l
                         && balanced r

c) halve xs = (take n xs, drop n x)
              where
                 n = length xs `div` 2

d) balance [x] = Leaf x
   balance xs  = Node (balance ys) (balance zs)
                 where
                    (ys,zs) = halve xs

e) mirror (Leaf x)   = Leaf x
   mirror (Node l r) = Node (mirror r) (mirror l)

f) Base case:

     balanced (mirror (Leaf x))
   =    applying mirror
     balanced (Leaf x)

   Inductive case:
   
     balanced (mirror (Node l r))
   =    applying mirror
     balanced (Node (mirror r) (mirror l))
   =    applying balanced
     size (mirror r) == size (mirror l)
     && balanced (mirror r) && balanced (mirror l)
   =    lemma, induction hypothesis
     size r == size l && balanced r && balanced l
   =    commutativity
     size l == size r && balanced l && balanced r
   =    unapplying balanced
     balanced (Node l r)

----------------------------------------------------------------------
